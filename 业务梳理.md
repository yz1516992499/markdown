###  合同流程相关

----

#### **获取合同详情**

`getContractFabricDetail`

> 获取Fabric合同详情（合同 ID、当前用户、用户类型、合同签名参与者列表）
>
> 使用`webClientService`发起请求
>
> 将响应数据转换为 `ContractFabricAppDetailJsonView` 返回

------

#### **复制签署合同**

`contractCopySignedToPreviewWithNewName`

> 接受合同 ID
>
> 获取合同对象
>
> 将已签署的合同文件复制为新的预览文件
>
> 调用 `contractService` 保存合同对象（`contract`）

-------

#### **预览签名**

`previewSignByAdvisor`、`previewSignByFinder`、`previewSignByUplineFinder`

> 接收合同ID和签名照片
>
> 获取指定`id`和状态为`PREPARE`的合同信息
>
> 创建并初始化合同预览签名页面对象`ContractPreviewSignPageAppJsonView`
>
> 设置合同预览页面的各项属性，包括合同的基本信息和关联的加入请求信息
>
> 调用服务层的方法生成合同预览签名文件，并检查文件是否存在
>
> 如果文件存在，将其转换为PDF格式并发布转换事件，否则抛出文件未找到的异常

-------

#### **ADVISOR签名**

`signByAdvisor`

> 接收合同ID
>
> 获取当前登录用户信息
>
> 调用服务层方法，由Advisor签署合同（`signContractByAdvisor`）
>
> 创建签署合同记录（`sign_contract_record`)，发布相关事件（`PostRequestFabricCreateEvent`）
>
> 发布用户快照事件（`ApplicationUserSnapshotEvent`）
>
> 发布合同签署通知事件（`ContractSignedByAdvisorNotificationEvent`）
>
> 结束合同签署流程，保存合同（`contract`）

------

#### **Finder拒绝合同**

`rejectedByFinder`

> 接收合同ID和拒绝原因表单（`RejectContractForm`)
>
> 调用服务层方法拒绝合同（`rejectContract`）
>
> > 接受合同实体类（`entity`)
> >
> > 检查加入请求状态是否为`PENDING`和`ACTIVE`
> >
> > 更新合同状态到`INACTIVE`
> >
> > 保存合同记录
>
> 拒绝合同谈判记录（`rejectContractNegotiationRecord`)
>
> > 接收合同ID和拒绝原因表单（`RejectContractForm`)
> >
> > 获取合同谈判记录列表
> >
> > 如果是序列号为1且状态为`PROPOSED`，调用`rejectContractNegotiationRecord`方法处理拒绝操作，否则，直接调用`rejectContractNegotiationRecord`方法处理拒绝操作
>
> 发送包含拒绝理由和备注的通知邮件
>
> 结束合同签署流程（`endSigningProcess`)
>
> > 更新*`isInSigningProcess`* = *`false`*; *`signingProcessBy`* = *`null`*
> >
> > 保存合同记录
>
> 更新相关通知状态，并发布合同拒绝通知事件
>
> > 获取与当前合同相关的通知列表（`getNotificationList`)
> >
> > 更新每条通知状态，标记为只读（`updateNotification`)
> >
> > 发布`ContractRejectByFinderNotificationEvent`事件，包含合同拒绝通知的信息
> >
> > > 获取加入请求记录（`joinRequestRecord`)
> > >
> > > 过滤发送者，提取所有参与者
> > >
> > > 创建通知对象
> > >
> > > 如果为订阅者模式，则向所有参与者发送消息

-------

#### **Advisor保持原合同**

`keepByAdvisor`

> 保持合同（`keepContract`)
>
> > 检查合同状态（*`INACTIVE`*）
> >
> > 更新合同状态 （*`OPEN_FOR_SIGNAGE`*）
> >
> > 保存更新后的合同
> >
> > 更新通知（`updateNotification`)
> >
> > > 获取相关通知
> > >
> > > 更新通知为只读
>
> 保持合同协商记录（`keepContractNegotiationRecord`)
>
> > 获取合同协商记录列表
> >
> > 对协商记录列表进行处理
> >
> > >初始化*`sequence*`变量，值为列表数量加一
> > >
> > >过滤类型为*`NegotiationType.REJECTED.value`*的谈判记录
> > >
> > >对剩下的记录进行迭代，并用`keepContractNegotiationRecord2`方法更新记录，然后递增*`sequence`*
> > >
> > >> **接受合同协商记录实体（*`entity`*）和*`index`***
> > >>
> > >> 过滤状态（*`STATUS`*)是*`ACTIVE`*的合同协商记录
> > >>
> > >> 创建新的合同协商记录实体，*`sequence`*属性设置为*`index`*
> > >>
> > >> 保存新的合同协商记录
> > >
> > >对最后一条*`REJECTED`*状态的记录进行处理（`keepContractNegotiationRecord`）
> > >
> > >> 接受合同协商记录实体（*`entity`*）和*`index`*
> > >>
> > >> 过滤*`STATUS`*是*`ACTIVE`*并且*`NegotiationType`*是*`REJECTED`*的合同协商记录
> > >>
> > >> 创建新的合同协商记录实体
> > >>
> > >> > *`requesterUserId`* 设置为当前应用用户的实体 ID
> > >> >
> > >> > *`sequence`* 属性设置为原始记录的 *`sequence`* 加上传入的索引号 *`index`*
> > >> >
> > >> > *`type`* 设置为 *`NegotiationType.PROPOSED.value`*
> > >> >
> > >> > *`STATUS`*设置为*`Status.ACTIVE.value`*
> > >>
> > >> 保存新的合同协商记录
>
> 结束签署流程（`endSigningProcess`）
>
> > 更新*`isInSigningProcess`* = *`false`*; *`signingProcessBy`* = *`null`*
> >
> > 保存合同记录
>
> 触发合同保持通知事件（`ContractKeepNotificationEvent`)

----

-------



---

---

### **合同模板相关**

----

#### 创建合同模板

`contractTemplateBackendService.create`

> 检查*`userId`*是否存在
>
> 创建并初始化*`ContractTemplate`*对象
>
> > *`ContractTemplate`*对象的各个字段通过 传入的*`form`* 参数中的值进行初始化
> >
> > *`entityId`*和*`excelDataFile`*字段分别处理文件上传，并将路径赋值给相应字段
> >
> > 上传*`wordTemplateFile`*后，发布*`ContractTemplateWordToPdfEvent`*事件
>
> 保存*`ContractTemplate`*对象
>
> > 调用*`contractTemplateDataSourceService.save`*方法保存*`ContractTemplate`*到数据库
>
> 如果*`userId`*为空则抛出异常

---

#### 更新合同模板

`contractTemplateBackendService.update`

> 接受两个参数
>
> > *`groupId`*
> >
> > *`form`*
>
> 查询合同模板
>
> > 调用*`getContractTemplateList`*方法，根据*`groupId`*、*`form.userId`*和状态为*`ACTIVE`*查询合同模板列表
> >
> > 使用*`SortRequest`*对结果进行排序，按照*`versionNumber`*字段降序排列
> >
> > 使用*`firstOrNull`*获取第一个合同模板，如果找不到任何合同模板，则返回*`null`*
>
> 更新合同模板
>
> > 如果找到了合同模板，则调用*`updateContractTemplate`*方法来更新合同模板
>
> 如果未找到合同模板，则抛出异常

----

#### 更改合同模板

`contractTemplateBackendService.change`

> 定义*`changeContractTemplate`*函数
>
> > 函数接受两个参数
> >
> > > 当前合同模板实体：*`entity`*
> > >
> > > 修改合同模板的表单数据；*`form`*
>
> 根据用户*`ID`*判断是否可以修改
>
> > 验证*`ID`*是否为空
> >
> > 验证当前合同模板是否属于该用户
>
> 创建新的合同模板实体
>
> > 创建一个新的合同模板实体，并根据表单数据或当前模板数据设置各个属性
> >
> > 使用*`contractTemplateDataSourceService.save`*保存到数据库
>
> 设置旧合同模板未不可用
>
> > 如果当前合同模板不是无效状态，则将其状态设置成不可用*`INACTIVE`*并保存到数据库中

-----

#### 删除合同模板

`contractTemplateBackendService.delete`

> 定义 *`deleteContractTemplate`*函数
>
> > 接受参数
> >
> > > 合同模板实体：*`entity`*
>
> 删除合同模板
>
> > 调用*`contractTemplateDataSourceService.delete`*删除合同模板实体
>
> 创建历史记录
>
> > 调用*`historyService.createHistory `*方法创建历史记录，记录删除合同模板的操作

----

#### 校验合同模板

`msOperationService.keyDifference`

> 接受三个参数
>
> > *`wordFilePath`*
> >
> > *`excelFilePath`*
> >
> > *`type`*
>
> 调用*`wordGetKeyList`*函数获取`WORD`文件中的键列表，并将其存储在`wordList`变量中
>
> 定义*`predefineMap`*
>
> > 根据*`type`*参数的值，定义一个包含预定义键的列表*`predefineMap`*
>
> 定义*`sheetNumber`*
>
> > 根据*`type`*参数的值来定义*`sheetNumber`*
>
> 计算*`list1`*和*`list2`*
>
> > *`list1`*是预定义键和`WORD`文件键的并集，去重后减去`WORD`文件键的结果
> >
> > *`list2`*是`WORD`文件键和`EXCEL`文件键的对称差
>
> 合并*`list1`*和*`list2`*并返回结果
>
> > 如果 *`list1`* 不为空，则在其后添加分隔线 *`---Word SEPARATE LINE $type---`*，然后再添加 *`list2`*。
> >
> > 如果 *`list1`* 为空，则直接将 *`list2`* 添加到 *`list1`* 中

---

---

### 积分规则相关

----

#### **登录/`LOGIN`**

`Authorization`

> 获取系统设置的积分相关配置（`systemSettingService.getSystemSettingItemListBySystemSettingGroup`)
>
> 获取用户积分历史记录
>
> > 通过`applicationUserPointHistoryService.getApplicationUserPointHistoryList`获取用户的积分历史记录，*`eventType`* = *`LOGGING_IN`*
>
> 检查用户是否符合获得登录积分的条件
>
> > 检查用户是否没有登录积分历史记录，或者最后一次获得登录积分的时间是否超过系统设置的登录积分间隔天数，判断用户是否符合获得新的登录积分的条件
>
> 获取登录积分的数值
>
> > 通过`masterDataService.getMasterDataList`获取登录积分的数值，并将其格式化为*`BigDecimal`*类型
>
> 增加用户积分
>
> > 通过`applicationUserPointService.plusApplicationUserPoint`为用户增加积分
>
> 创建积分历史
>
> > 创建`CreateApplicationUserPointHistoryForm`对象
>
> 

-----

#### **项目方已批准投资者/`APPROVED BY ADVISOR`**

`SaveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 监听事件`InvestmentSatus`为*``ADVISOR_APPROVED_INVESTOR``*、*`FINDER_PROVIDED_CONTACT_INFORMATION`*、*`WAITING_FOR_CONTACT_INFORMATION`*调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = ADVISOR_APPROVED_INVESTOR`*

> <font color="red">*Note:*</font> *`ADVISOR_APPROVED_INVESTOR`*、*`WAITING_FOR_CONTACT_INFORMATION`*状态未实际使用.实际在分享联系方式后增加积分。

------

#### **投资者已回复客户/`INVESTOR CONFIRMED`**

`SaveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 监听事件*`InvestmentSatus`*为*`INVESTOR_CONFIRMED_REFERRAL`*,调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = INVESTOR_CONFIRMED_REFERRAL`*

> <font color="red">*Note:*</font> 实际在*`Advisor`*进行*`well received`*操作后修改积分。

----

#### **投资者账户已支付/`INVESTOR MADE INVESTMENT`**

`SaveInvestmentRecord`

> > 接收*`IvestormentRecord`*类型的*`entity`*
> >
> > 保存投资记录
> >
> > > 调用`investmentRecordDataSourceService.save`保存投资记录
> >
> > 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
> >
> > > 监听事件*`InvestmentSatus`*为*`INVESTMENT_ACCOUNT_HAS_BEEN_PAID`*,调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = INVESTOR_SIGNED_NDA`*

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`INVESTMENT_ACCOUNT_HAS_BEEN_PAID`*操作后修改积分。

------

#### **投资者已签NDA/`INVESTOR SIGN NDA`**

`SaveInvestmentRecord`

> > 接收*`IvestormentRecord`*类型的*`entity`*
> >
> > 保存投资记录
> >
> > > 调用`investmentRecordDataSourceService.save`保存投资记录
> >
> > 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
> >
> > > 监听事件*`InvestmentSatus`*为*`INVESTOR_SIGNED_NDA`*,调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = INVESTOR_SIGNED_NDA`*

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`INVESTOR_SIGNED_NDA`*操作后修改积分。

------

#### **投资者已签意向书/`INVESTOR SIGNED MOU`**

`SaveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 根据*`entity.investmentStatus`*的属性值执行不同的监听逻辑
> >
> > 若*`InvestmentSatus`*为*`LETTER_OF_INTENT_OR_MOU_SIGNED`*,则调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = LETTER_OF_INTENT_OR_MOU_SIGNED`*

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`LETTER_OF_INTENT_OR_MOU_SIGNED`*操作后修改积分。

----

#### **投资者已签投资条件书/`INVESTOR SIGNED TERM SHEET`**

`SaveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 根据*`entity.investmentStatus`*的属性值执行不同的监听逻辑
> >
> > 若*`InvestmentSatus`*为*`TERM_SHEET_SIGNED`*,则调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = INVESTOR_SIGNED_TERM_SHEET`*

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`TERM_SHEET_SIGNED`*操作后修改积分。

----

#### **受邀兄弟赚取积分部分(1/10)/`INVITEE BRO EARN POINTS`**

`InviteeBroEarnPointCalculate`

> 接收参数
>
> > *`currentPoint`*：*`BigDecimal`* //当前*`Finder`*获得的积分数
> >
> > *`entity`*；*`ApplicationUserPoint`* // *`ApplicationUserPoint`*实体
>
> 计算积分奖励
>
> > 获取积分值*`eventType = INVLITEE_BRO_EARN_POINT `*并赋值给*`eventPoint`*
> >
> > 计算受邀积分值
> >
> > > ```java
> > > currentPoint?.divide(eventPoint)?.toBigDecimalDollarFormat() //最终获取的积分为：兄弟获取积分/类型积分
> > > ```
> >
> > 获取邀请人并更新积分
> >
> > > ```java
> > > entity.applicationUser?.applicationUserInformation?.referredBy?.let { _invitee ->
> > >     _invitee.applicationUserPoint?.let { _inviteePoint -> //从外键获取推荐人ID
> > > ```
> >
> > 创建或更新*`ApplicationUserPointHistory`*并且*`eventType = INVLITEE_BRO_EARN_POINT `*

-----

#### **已确认投资人数/`NUMBER OF INVESTOR CONFIRMED`**

`CheckSuggestionEvent`

> 获取用户*`ID`*
>
> 定义事件类型和计数阈值
>
> > *`eventType = NUMBER_OF_INVESTOR_CONFIRMED`*
> >
> > *`numberToCount = 20`* // 每次计算所需的确认投资者数量
>
> 计算已接受的投资者数量
>
> > 获取用户所有的建议记录
> >
> > 过滤出状态为*`ACCEPTED`*且类型为*`INVESTOR`*的建议项
> >
> > 计算这些建议项的总数赋值给*`totalAcceptedInvestor`*
>
> 获取已计入的接受投资者数量
>
> > 获取用户积分历史并过滤类型为*`NUMBER_OF_INVESTOR_CONFIRMED`*的记录
> >
> > 从记录中获取已计入的接受投资者数量，并更新`countedAcceptedInvestor`
>
> 获取积分数据并计算新积分
>
> > 获取积分数据 *`pointData`*，并转换为 *`BigDecimal`* 格式的 *`point`*。
> >
> > 使用*`while`*循环计算应得积分直到新接受的建议数量不足20
> >
> > 更新积分历史表
> >
> > 调用` applicationUserPointService.plusApplicationUserPoint`更新用户积分

> <font color="red">*Note:*</font> 在`ScheduledTaskConfig.standardTaskCheckSuggestion`和`MainFlowAdvisorAppServiceImol.updateSuggestionList`里调用该监听

-----

#### **NDA的投资者数量/`NUMBER OF INVESIOR SIGNED NDA`**

`saveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 监听事件*`InvestmentSatus`*为*`INVESTOR_SIGNED_NDA`*,调用`CheckInvestmentRecordEvent`
> >
> > 查询积分历史找出最新的一条记录判断*`state`*字段是否包括当前*`investmentRecordId`*，不包含就加入并将字段里的*`investmentRecordId`*的数量赋值给*`newState`*
> >
> > 初始化计数参数*`numberToCount = 10`*（其他情况初始化为1)
> >
> > 初始化已签署*`NDA`*投资者计数参数*`countedSignedNDAInvestor = 0`*
> >
> > 查询积分历史获得加分数量为*`NUMBER_OF_INVESTOR_SIGNED_NDA`*的对应数值的记录数量并赋值给*`totalSignNDAEvent`*
> >
> > 计算是否满足加分条件
> >
> > > ```java
> > > countedSignedNDAInvestor = newState.count() - totalSignNDAEvent * numberToCount
> > > countedSignedNDAInvestor.takeIf { it >= numberToCount }?.let {
> > > _pointData.value?.toBigDecimal() //满十人就加一次分
> > > } ?: BigDecimal.ZERO //不满十人加0分
> > > ```

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`INVESTOR_SIGNED_NDA`*操作后并且满足每推荐十个人时加分，如果不满10的倍数就加0分。

-----

#### 签署中间人协议名/`SIGNED FINDER AGREEMENT`

`ContractReadyToUploadEvent`

> 获取*`joinRequestRecordId`*
>
> 获取并验证*`joinRequestRecord`*记录状态
>
> > *`joinRequest`*的状态为`PENDING`
> >
> > *`partticipantList`*和*`signParticipantList`*的数量相同
> >
> > *`participantList`*和*`signParticipantList`*的内容相同
>
> 处理合同
>
> > 如果合同状态是*`OPEN_SIGNAGE`*或*`UPLOADING`*，则进行以下操作
> >
> > > 检查签署的*`Word`*文件是否存在并上传至*`IPFS`*，获取*`IPFS`*哈希值
> > >
> > > 更新合同的*`signedIpfsHash`*
>
> 保存合同记录
>
> > 保存合同相关的*`joinRequest`*和*`contract`*记录，并更新合同状态为*`ACTIVE`*
>
> 更新参与者的项目记录
>
> > 更新参与者的*`MyBroRecord`*，将项目*`ID`*添加到参与者的*`joinedProjectIdList`*中
>
> 处理加入请求记录
>
> > 接受加入请求记录，并发布积分事件（*`PlusPointEvent`*）给请求者（*`requesterUserId`*）和上级用户（*`upLinerUserId`*）
>
> 处理上级用户的*`MyBroRecord`*
>
> > 如果存在上级用户，更新或创建相应的*`MyBroRecord`*，标记为*`isDownLine`*或*`isUpLine`*
>
> 更新通知为只读

> <font color="red">*Note:*</font> `ContractAppRestController("ready-to-active")`、`ContractAppServiceImpl.signByFinder`和
>
> `ScheduleServiceImpl.contractReadyToUpload`调用监听

-----

#### **签署投资协议/`SIGNED INVESTMENT AGREEMENT`**

`SaveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 根据*`entity.investmentStatus`*的属性值执行不同的监听逻辑
> >
> > 若*`InvestmentSatus`*为*`INVESTMENT_AGREEMENT_SIGNED`*,则调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = INVESTMENT_AGREEMENT_SIGNED`*

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`INVESTMENT_AGREEMENT_SIGNED`*操作后修改积分。

----

#### **新增投资者**/`ADD NEW INVESTOR`

`MyBroRecordAppServiceImpl.create`

> 创建*`MyBroRecord`*对象
>
> > 根据*`form`*的*`type`*字段，决定是创建*`Finder`*类型的记录还是一般的*`MyBroRecord`*
> >
> > 如果*`type = FINDER`*，调用*`createMyBroRecordFinder`*方法，否则调用*`createMyBroRecord`*方法
>
> 处理创建后的*`MyBroRecord`*
>
> > 初始化*`eventList`*来存储发布积分事件的类型
> >
> > 检查*`myBro`*类型是否为*`INVESTOR`*
> >
> > > *`if-yes`*: 将*`ADD_NEW_INVESTOR`*事件添加到*`eventList`*中
> > >
> > > 检查*`firstName`*和*`lastName`*是否不为空，如果不为空
> > >
> > > > 更新*`MyBroRecord`*，设置*`isFillFullName = true`*
> > > >
> > > > 将*`ADD_FULL_NAME_OF_INVESTOR`*事件添加到*`eventList`*
> > >
> > > 发布*`PlusPointEvent`*，包含所需要发布的积分事件类型和相关数据

----

#### **填写投资者全名**/`INVESTOR - FILLING FULL NAME`

`MyBroRecordAppServiceImpl.create`

> <font color="red">NOTE:</font>创建部分在新增投资者

`MyBroRecordAppServiceImpl.update`

> 更新*`MyBroRecord`*对象
>
> > 通过*`ID`*和*`form`*参数，调用`myBroRecordService.updateMyBroRecord`方法更新*`MyBroRecord`*对象
>
> 处理更新后的*`MyBroRecord`*对象
>
> > 检查事件发布条件是否满足
> >
> > > *`myBro.firstName`*不为空且不为空字符串。
> > >
> > > *`myBro.lastName`* 不为空且不为空字符串。
> > >
> > > *`myBro.isFillFullName`* 为 `false`（表示之前未填写完整姓名）。
> >
> > 如果上述条件都满足
> >
> > > 再次更新 *`MyBroRecord`* 对象，设置 *`isFillFullName = false`*。
> > >
> > > 发布 *`PlusPointEvent`* 事件，事件类型为 *`ADD_FULL_NAME_OF_INVESTOR`*。

---

----



---

----

### 主流程ADVISOR

----

#### 回复推荐

`MainFlowAdvisorAppServiceImpl.updateSuggestion`

> 定义*`updateSuggestion`*函数
>
> > 接受参数
> >
> > > 记录的*`ID`*
> > >
> > > 表单对象*`form`*
>
> 调用服务更新建议记录
>
> > 使用*`mainFlowSuggestionRecordService.updateMainFlowSuggestionRecord `*方法更新建议记录，传入的参数是*`id`*和转换后的表单对象
> >
> > > 定义*`updateMainFlowSuggestionRecord`*函数
> > >
> > > > 接受参数
> > > >
> > > > > 要更新的主流程建议记录；*`entity`*
> > > > >
> > > > > 包含更新信息的表单：*`form`*
> > > >
> > > > 更新建议实体记录
> > > >
> > > > 处理建议项列表
> > > >
> > > > > 获取项目*`ID`*，并对表单中的建议项列表进行处理
> > > > >
> > > > > 获取并更新每个建议项的状态和理由
> > > >
> > > > 处理不同状态的建议项
> > > >
> > > > > 接受状态
> > > > >
> > > > > 拒绝状态
> > > > >
> > > > > > 调用*`myBroRecordService.updateMyBroRecord`*方法更新*`MyBro`*记录
> > > > > >
> > > > > > 更新表单*`UpdateMyBroRecordForm`*包含一个字段*`removeSuggestedToProjectId`*，用来移除与该项目相关的建议记录
> > > > >
> > > > > 更新后操作
> > > > >
> > > > > > 检查建议项的类型是否为*`FINDER`*
> > > > > >
> > > > > > 调用*`investmentRecordService.getInvestmentRecordList`*方法获取与该项目和*`MyBro`*记录相关的投资记录列表
> > > > > >
> > > > > > 如果找到相关的投资记录，则调用*`investmentRecordService.deleteInvestmentRecord`*方法删除该投资记录
>
> 检查用户并发布时间
>
> > 使用*`takeIf`*检查更新后的建议记录*`requestUserId`*是否与当前用户的*`entityId`*不同
> >
> > 如果不同则发布*`SuggestionResponseNotificationEvent`*事件，通知接收者（即原始请求者）该建议记录已被更新

----

#### 拒绝加入

`MainFlowAdvisorAppServiceImpl.rejectJoinRequest`

> 定义*`rejectJoinRequest`*函数
>
> > 接受参数
> >
> > > 加入请求的记录*`ID`*
> > >
> > > 表单对象*`form`*
>
> 检查用户类型
>
> > 使用*`takeIf`*检查当前用户是否为*`ADVISOR`*类型
>
> 调用服务拒绝加入请求记录
>
> > 使用*`mainFlowJoinRequestRecordService.rejectMainFlowJoinRequestRecord `*方法拒绝加入请求记录，传入的参数是*`ID`*转换后的表单对象
> >
> > > 接受*`MainFlowJoinRequestRecord`*实体和一个*`RejectMainFlowJoinRequestRecordForm`*表单作为参数
> > >
> > > 处理记录状态
> > >
> > > > 检查记录状态是否为*`PENDING`*
> > > >
> > > > 如果是则更新为*`REJECTED`*
> > > >
> > > > 更新拒绝的原因*`reason`*，如果表单中提供了原因且不为空白，则使用表单中的原因，否则保留原有的原因
> > >
> > > 保存更新后的记录
> > >
> > > > 调用*`mainFlowJoinRequestRecordDataSourceService.save`*保存更新后的记录
>
> 处理相关记录和通知
>
> > 检查*`_joinRequestRecord`*的*`entity`*是否存在
>
> 删除相关谈判记录
>
> > 删除与该请求记录相关的所有活跃状态的谈判记录，并更新其通知为只读
>
> 删除相关合同
>
> > 删除与该请求记录相关的所有准备状态和开放签署状态的合同，并更新其通知为只读状态
>
> 发布删除事件
>
> > 发布一个*`JoinRequestDeletedByAdvisorNotificationEvent`*事件，通知相关参与者该加入请求记录已被顾问删除
>
> 更新通知状态为只读
>
> 处理上级用户的建议
>
> > 获取与该加入请求记录相关的所有建议项，并更新其状态为已拒绝（*`REJECTED`*）

---

#### 接受协商

`MainFlowAdvisorAppServiceImpl.acceptCommissionNegotiationRecord`

> 定义*`acceptCommissionNegotiationRecord`*函数
>
> > 接受参数；谈判记录的*`ID`*
>
> 接受佣金谈判记录
>
> > 调用*`mainFlowCommissionNegotiationRecordService.acceptMainFlowCommissionNegotiationRecord `*方法接受指定*`ID`*的佣金谈判记录
> >
> > > 接受一个*`MainFlowCommissionNegotiationRecord`*类型的*`entity`*作为参数
> > >
> > > 检查当前记录是否有效
> > >
> > > > 检查记录的状态是否为*`ACTIVE`*
> > > >
> > > > 检查谈判类型是否为*`PROPOSED`*
> > > >
> > > > 检查关联的加入请求记录的状态是否为*`PENDING`*
> > >
> > > 获取当前用户并验证权限
> > >
> > > > 获取当前用户的*`entityId`*并检查用户是否有权限接受该记录
> > > >
> > > > 当前用户不能是请求用户，并且必须是加入请求的请求用户、项目用户或上级用户
> > >
> > > 创建新的佣金谈判记录
> > >
> > > > 创建一个新的*`MainFlowCommissionNegotiationRecord`*对象，并设置相关属性
> > > >
> > > > 根据不同的*`NegotiateTargetType`*和*`CommissionMechanismType`*验证佣金百分比是否在允许范围内
> > > >
> > > > 设置新的记录类型为*`ACCEPTED`*，状态为*`ACTIVE`*
> > >
> > > 保存记录并发布事件
> > >
> > > > 保存佣金谈判记录
> > > >
> > > > 发布*`CommissionNegotiationAcceptNotificationEvent`*事件，通知相关用户谈判记录已被接受
>
> 处理后续操作
>
> > 获取与该谈判记录关联的所有*`MainFlowCommissionNegotiationRecord`*记录列表
> >
> > 遍历这些记录，对于每个记录，获取其*`entityId`*，并使用该*`ID`*获取所有相关的通知
> >
> > 对于每个通知，调用*`notificationService.updateNotification`*方法，将其更新为只读状态

---

