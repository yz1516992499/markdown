###  合同流程相关

----

-----

#### **获取合同详情**

`getContractFabricDetail`

> 获取Fabric合同详情（合同 ID、当前用户、用户类型、合同签名参与者列表）
>
> 使用`webClientService`发起请求
>
> 将响应数据转换为 `ContractFabricAppDetailJsonView` 返回

------

#### **复制签署合同**

`contractCopySignedToPreviewWithNewName`

> 接受合同 ID
>
> 获取合同对象
>
> 将已签署的合同文件复制为新的预览文件
>
> 调用 `contractService` 保存合同对象（`contract`）

-------

#### **预览签名**

`previewSignByAdvisor`、`previewSignByFinder`、`previewSignByUplineFinder`

> 接收合同ID和签名照片
>
> 获取指定`id`和状态为`PREPARE`的合同信息
>
> 创建并初始化合同预览签名页面对象`ContractPreviewSignPageAppJsonView`
>
> 设置合同预览页面的各项属性，包括合同的基本信息和关联的加入请求信息
>
> 调用服务层的方法生成合同预览签名文件，并检查文件是否存在
>
> 如果文件存在，将其转换为PDF格式并发布转换事件，否则抛出文件未找到的异常

-------

#### **签名**

`signByAdvisor`

> 接收合同ID
>
> 获取当前登录用户信息
>
> 调用服务层方法，由Advisor签署合同（`signContractByAdvisor`）
>
> 创建签署合同记录（`sign_contract_record`)，发布相关事件（`PostRequestFabricCreateEvent`）
>
> 发布用户快照事件（`ApplicationUserSnapshotEvent`）
>
> 发布合同签署通知事件（`ContractSignedByAdvisorNotificationEvent`）
>
> 结束合同签署流程，保存合同（`contract`）

------

#### **Finder拒绝合同**

`rejectedByFinder`

> 接收合同ID和拒绝原因表单（`RejectContractForm`)
>
> 调用服务层方法拒绝合同（`rejectContract`）
>
> > 接受合同实体类（`entity`)
> >
> > 检查加入请求状态是否为`PENDING`和`ACTIVE`
> >
> > 更新合同状态到`INACTIVE`
> >
> > 保存合同记录
>
> 拒绝合同谈判记录（`rejectContractNegotiationRecord`)
>
> > 接收合同ID和拒绝原因表单（`RejectContractForm`)
> >
> > 获取合同谈判记录列表
> >
> > 如果是序列号为1且状态为`PROPOSED`，调用`rejectContractNegotiationRecord`方法处理拒绝操作，否则，直接调用`rejectContractNegotiationRecord`方法处理拒绝操作
>
> 发送包含拒绝理由和备注的通知邮件
>
> 结束合同签署流程（`endSigningProcess`)
>
> > 更新*`isInSigningProcess`* = *`false`*; *`signingProcessBy`* = *`null`*
> >
> > 保存合同记录
>
> 更新相关通知状态，并发布合同拒绝通知事件
>
> > 获取与当前合同相关的通知列表（`getNotificationList`)
> >
> > 更新每条通知状态，标记为只读（`updateNotification`)
> >
> > 发布`ContractRejectByFinderNotificationEvent`事件，包含合同拒绝通知的信息
> >
> > > 获取加入请求记录（`joinRequestRecord`)
> > >
> > > 过滤发送者，提取所有参与者
> > >
> > > 创建通知对象
> > >
> > > 如果为订阅者模式，则向所有参与者发送消息

-------

#### **Advisor保持原合同**

`keepByAdvisor`

> 保持合同（`keepContract`)
>
> > 检查合同状态（*`INACTIVE`*）
> >
> > 更新合同状态 （*`OPEN_FOR_SIGNAGE`*）
> >
> > 保存更新后的合同
> >
> > 更新通知（`updateNotification`)
> >
> > > 获取相关通知
> > >
> > > 更新通知为只读
>
> 保持合同协商记录（`keepContractNegotiationRecord`)
>
> > 获取合同协商记录列表
> >
> > 对协商记录列表进行处理
> >
> > >初始化*`sequence*`变量，值为列表数量加一
> > >
> > >过滤类型为*`NegotiationType.REJECTED.value`*的谈判记录
> > >
> > >对剩下的记录进行迭代，并用`keepContractNegotiationRecord2`方法更新记录，然后递增*`sequence`*
> > >
> > >> **接受合同协商记录实体（*`entity`*）和*`index`***
> > >>
> > >> 过滤状态（*`STATUS`*)是*`ACTIVE`*的合同协商记录
> > >>
> > >> 创建新的合同协商记录实体，*`sequence`*属性设置为*`index`*
> > >>
> > >> 保存新的合同协商记录
> > >
> > >对最后一条*`REJECTED`*状态的记录进行处理（`keepContractNegotiationRecord`）
> > >
> > >> 接受合同协商记录实体（*`entity`*）和*`index`*
> > >>
> > >> 过滤*`STATUS`*是*`ACTIVE`*并且*`NegotiationType`*是*`REJECTED`*的合同协商记录
> > >>
> > >> 创建新的合同协商记录实体
> > >>
> > >> > *`requesterUserId`* 设置为当前应用用户的实体 ID
> > >> >
> > >> > *`sequence`* 属性设置为原始记录的 *`sequence`* 加上传入的索引号 *`index`*
> > >> >
> > >> > *`type`* 设置为 *`NegotiationType.PROPOSED.value`*
> > >> >
> > >> > *`STATUS`*设置为*`Status.ACTIVE.value`*
> > >>
> > >> 保存新的合同协商记录
>
> 结束签署流程（`endSigningProcess`）
>
> > 更新*`isInSigningProcess`* = *`false`*; *`signingProcessBy`* = *`null`*
> >
> > 保存合同记录
>
> 触发合同保持通知事件（`ContractKeepNotificationEvent`)

----

-------



### 积分规则相关

----

--------

#### **登录/`LOGIN`**

`Authorization`

> 获取系统设置的积分相关配置（`systemSettingService.getSystemSettingItemListBySystemSettingGroup`)
>
> 获取用户积分历史记录
>
> > 通过`applicationUserPointHistoryService.getApplicationUserPointHistoryList`获取用户的积分历史记录，*`eventType`* = *`LOGGING_IN`*
>
> 检查用户是否符合获得登录积分的条件
>
> > 检查用户是否没有登录积分历史记录，或者最后一次获得登录积分的时间是否超过系统设置的登录积分间隔天数，判断用户是否符合获得新的登录积分的条件
>
> 获取登录积分的数值
>
> > 通过`masterDataService.getMasterDataList`获取登录积分的数值，并将其格式化为*`BigDecimal`*类型
>
> 增加用户积分
>
> > 通过`applicationUserPointService.plusApplicationUserPoint`为用户增加积分
>
> 创建积分历史
>
> > 创建`CreateApplicationUserPointHistoryForm`对象
>
> 

-----

#### **项目方已批准投资者/`APPROVED BY ADVISOR`**

`SaveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 监听事件`InvestmentSatus`为*``ADVISOR_APPROVED_INVESTOR``*、*`FINDER_PROVIDED_CONTACT_INFORMATION`*、*`WAITING_FOR_CONTACT_INFORMATION`*调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = ADVISOR_APPROVED_INVESTOR`*

> <font color="red">*Note:*</font> *`ADVISOR_APPROVED_INVESTOR`*、*`WAITING_FOR_CONTACT_INFORMATION`*状态未实际使用.实际在分享联系方式后增加积分。

------

#### **投资者已回复客户/`INVESTOR CONFIRMED`**

`SaveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 监听事件*`InvestmentSatus`*为*`INVESTOR_CONFIRMED_REFERRAL`*,调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = INVESTOR_CONFIRMED_REFERRAL`*

> <font color="red">*Note:*</font> 实际在*`Advisor`*进行*`well received`*操作后修改积分。

----

#### **投资者账户已支付/`INVESTOR MADE INVESTMENT`**

`SaveInvestmentRecord`

> > 接收*`IvestormentRecord`*类型的*`entity`*
> >
> > 保存投资记录
> >
> > > 调用`investmentRecordDataSourceService.save`保存投资记录
> >
> > 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
> >
> > > 监听事件*`InvestmentSatus`*为*`INVESTMENT_ACCOUNT_HAS_BEEN_PAID`*,调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = INVESTOR_SIGNED_NDA`*

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`INVESTMENT_ACCOUNT_HAS_BEEN_PAID`*操作后修改积分。

------

#### **投资者已签NDA/`INVESTOR SIGN NDA`**

`SaveInvestmentRecord`

> > 接收*`IvestormentRecord`*类型的*`entity`*
> >
> > 保存投资记录
> >
> > > 调用`investmentRecordDataSourceService.save`保存投资记录
> >
> > 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
> >
> > > 监听事件*`InvestmentSatus`*为*`INVESTOR_SIGNED_NDA`*,调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = INVESTOR_SIGNED_NDA`*

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`INVESTOR_SIGNED_NDA`*操作后修改积分。

------

#### **投资者已签意向书/`INVESTOR SIGNED MOU`**

`SaveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 根据*`entity.investmentStatus`*的属性值执行不同的监听逻辑
> >
> > 若*`InvestmentSatus`*为*`LETTER_OF_INTENT_OR_MOU_SIGNED`*,则调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = LETTER_OF_INTENT_OR_MOU_SIGNED`*

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`LETTER_OF_INTENT_OR_MOU_SIGNED`*操作后修改积分。

----

#### **投资者已签投资条件书/`INVESTOR SIGNED TERM SHEET`**

`SaveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 根据*`entity.investmentStatus`*的属性值执行不同的监听逻辑
> >
> > 若*`InvestmentSatus`*为*`TERM_SHEET_SIGNED`*,则调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = INVESTOR_SIGNED_TERM_SHEET`*

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`TERM_SHEET_SIGNED`*操作后修改积分。

----

#### **受邀兄弟赚取积分部分(1/10)/`INVITEE BRO EARN POINTS`**

`InviteeBroEarnPointCalculate`

> 接收参数
>
> > *`currentPoint`*：*`BigDecimal`* //当前*`Finder`*获得的积分数
> >
> > *`entity`*；*`ApplicationUserPoint`* // *`ApplicationUserPoint`*实体
>
> 计算积分奖励
>
> > 获取积分值*`eventType = INVLITEE_BRO_EARN_POINT `*并赋值给*`eventPoint`*
> >
> > 计算受邀积分值
> >
> > > ```java
> > > currentPoint?.divide(eventPoint)?.toBigDecimalDollarFormat() //最终获取的积分为：兄弟获取积分/类型积分
> > > ```
> >
> > 获取邀请人并更新积分
> >
> > > ```java
> > > entity.applicationUser?.applicationUserInformation?.referredBy?.let { _invitee ->
> > >     _invitee.applicationUserPoint?.let { _inviteePoint -> //从外键获取推荐人ID
> > > ```
> >
> > 创建或更新*`ApplicationUserPointHistory`*并且*`eventType = INVLITEE_BRO_EARN_POINT `*

-----

#### **已确认投资人数/`NUMBER OF INVESTOR CONFIRMED`**

`CheckSuggestionEvent`

> 获取用户*`ID`*
>
> 定义事件类型和计数阈值
>
> > *`eventType = NUMBER_OF_INVESTOR_CONFIRMED`*
> >
> > *`numberToCount = 20`* // 每次计算所需的确认投资者数量
>
> 计算已接受的投资者数量
>
> > 获取用户所有的建议记录
> >
> > 过滤出状态为*`ACCEPTED`*且类型为*`INVESTOR`*的建议项
> >
> > 计算这些建议项的总数赋值给*`totalAcceptedInvestor`*
>
> 获取已计入的接受投资者数量
>
> > 获取用户积分历史并过滤类型为*`NUMBER_OF_INVESTOR_CONFIRMED`*的记录
> >
> > 从记录中获取已计入的接受投资者数量，并更新`countedAcceptedInvestor`
>
> 获取积分数据并计算新积分
>
> > 获取积分数据 *`pointData`*，并转换为 *`BigDecimal`* 格式的 *`point`*。
> >
> > 使用*`while`*循环计算应得积分直到新接受的建议数量不足20
> >
> > 更新积分历史表
> >
> > 调用` applicationUserPointService.plusApplicationUserPoint`更新用户积分

> <font color="red">*Note:*</font> 在`ScheduledTaskConfig.standardTaskCheckSuggestion`和`MainFlowAdvisorAppServiceImol.updateSuggestionList`里调用该监听

-----

#### **NDA的投资者数量/`NUMBER OF INVESIOR SIGNED NDA`**

`saveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 监听事件*`InvestmentSatus`*为*`INVESTOR_SIGNED_NDA`*,调用`CheckInvestmentRecordEvent`
> >
> > 查询积分历史找出最新的一条记录判断*`state`*字段是否包括当前*`investmentRecordId`*，不包含就加入并将字段里的*`investmentRecordId`*的数量赋值给*`newState`*
> >
> > 初始化计数参数*`numberToCount = 10`*（其他情况初始化为1)
> >
> > 初始化已签署*`NDA`*投资者计数参数*`countedSignedNDAInvestor = 0`*
> >
> > 查询积分历史获得加分数量为*`NUMBER_OF_INVESTOR_SIGNED_NDA`*的对应数值的记录数量并赋值给*`totalSignNDAEvent`*
> >
> > 计算是否满足加分条件
> >
> > > ```java
> > > countedSignedNDAInvestor = newState.count() - totalSignNDAEvent * numberToCount
> > > countedSignedNDAInvestor.takeIf { it >= numberToCount }?.let {
> > > _pointData.value?.toBigDecimal() //满十人就加一次分
> > > } ?: BigDecimal.ZERO //不满十人加0分
> > > ```

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`INVESTOR_SIGNED_NDA`*操作后并且满足每推荐十个人时加分，如果不满10的倍数就加0分。

-----

#### 签署中间人协议名/`SIGNED FINDER AGREEMENT`

`ContractReadyToUploadEvent`

> 获取*`joinRequestRecordId`*
>
> 获取并验证*`joinRequestRecord`*记录状态
>
> > *`joinRequest`*的状态为`PENDING`
> >
> > *`partticipantList`*和*`signParticipantList`*的数量相同
> >
> > *`participantList`*和*`signParticipantList`*的内容相同
>
> 处理合同
>
> > 如果合同状态是*`OPEN_SIGNAGE`*或*`UPLOADING`*，则进行以下操作
> >
> > > 检查签署的*`Word`*文件是否存在并上传至*`IPFS`*，获取*`IPFS`*哈希值
> > >
> > > 更新合同的*`signedIpfsHash`*
>
> 保存合同记录
>
> > 保存合同相关的*`joinRequest`*和*`contract`*记录，并更新合同状态为*`ACTIVE`*
>
> 更新参与者的项目记录
>
> > 更新参与者的*`MyBroRecord`*，将项目*`ID`*添加到参与者的*`joinedProjectIdList`*中
>
> 处理加入请求记录
>
> > 接受加入请求记录，并发布积分事件（*`PlusPointEvent`*）给请求者（*`requesterUserId`*）和上级用户（*`upLinerUserId`*）
>
> 处理上级用户的*`MyBroRecord`*
>
> > 如果存在上级用户，更新或创建相应的*`MyBroRecord`*，标记为*`isDownLine`*或*`isUpLine`*
>
> 更新通知为只读

> <font color="red">*Note:*</font> `ContractAppRestController("ready-to-active")`、`ContractAppServiceImpl.signByFinder`和
>
> `ScheduleServiceImpl.contractReadyToUpload`调用监听

-----

#### **签署投资协议/`SIGNED INVESTMENT AGREEMENT`**

`SaveInvestmentRecord`

> 接收*`IvestormentRecord`*类型的*`entity`*
>
> 保存投资记录
>
> > 调用`investmentRecordDataSourceService.save`保存投资记录
>
> 根据投资状态触发事件（`CheckInvestmentRecordEvent`）
>
> > 根据*`entity.investmentStatus`*的属性值执行不同的监听逻辑
> >
> > 若*`InvestmentSatus`*为*`INVESTMENT_AGREEMENT_SIGNED`*,则调用`CheckInvestmentRecordEvent`进行积分的修改操作，并且本次修改的*`eventType = INVESTMENT_AGREEMENT_SIGNED`*

> <font color="red">*Note:*</font> 实际在项目的*`Advisor`*在后台更新*`investmentStatus`*为*`INVESTMENT_AGREEMENT_SIGNED`*操作后修改积分。

----

#### **新增投资者**/`ADD NEW INVESTOR`

`MyBroRecordAppServiceImpl.create`

> 创建*`MyBroRecord`*对象
>
> > 根据*`form`*的*`type`*字段，决定是创建*`Finder`*类型的记录还是一般的*`MyBroRecord`*
> >
> > 如果*`type = FINDER`*，调用*`createMyBroRecordFinder`*方法，否则调用*`createMyBroRecord`*方法
>
> 处理创建后的*`MyBroRecord`*
>
> > 初始化*`eventList`*来存储发布积分事件的类型
> >
> > 检查*`myBro`*类型是否为*`INVESTOR`*
> >
> > > *`if-yes`*: 将*`ADD_NEW_INVESTOR`*事件添加到*`eventList`*中
> > >
> > > 检查*`firstName`*和*`lastName`*是否不为空，如果不为空
> > >
> > > > 更新*`MyBroRecord`*，设置*`isFillFullName = true`*
> > > >
> > > > 将*`ADD_FULL_NAME_OF_INVESTOR`*事件添加到*`eventList`*
> > >
> > > 发布*`PlusPointEvent`*，包含所需要发布的积分事件类型和相关数据

----

#### **填写投资者全名**/`INVESTOR - FILLING FULL NAME`

`MyBroRecordAppServiceImpl.create`

> <font color="red">NOTE:</font>创建部分在新增投资者

`MyBroRecordAppServiceImpl.update`

> 更新*`MyBroRecord`*对象
>
> > 通过*`ID`*和*`form`*参数，调用`myBroRecordService.updateMyBroRecord`方法更新*`MyBroRecord`*对象
>
> 处理更新后的*`MyBroRecord`*对象
>
> > 检查事件发布条件是否满足
> >
> > > *`myBro.firstName`*不为空且不为空字符串。
> > >
> > > *`myBro.lastName`* 不为空且不为空字符串。
> > >
> > > *`myBro.isFillFullName`* 为 `false`（表示之前未填写完整姓名）。
> >
> > 如果上述条件都满足
> >
> > > 再次更新 *`MyBroRecord`* 对象，设置 *`isFillFullName = false`*。
> > >
> > > 发布 *`PlusPointEvent`* 事件，事件类型为 *`ADD_FULL_NAME_OF_INVESTOR`*。





